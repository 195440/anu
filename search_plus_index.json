{"./":{"url":"./","title":"介绍","keywords":"","body":"anu npm install anujs anu, 读作［安努］，原意为苏美尔的主神。 此框架的创立之意有三： 提升性能， 虽然React的性能相对于传统的MVVM框架是很厉害了，但近几年冒出来的diff算法比官方版更优秀，官方版积重难返，很难短时期吸收这些成果。anu则小船好调头，第一时间收纳其中。性能是王道。天下武功，唯快不破。 压缩体积。 React+React-dom加起来有三万多行，这么大的体量任何code splitting与按需加载技术都无能为力，因此我们需要迷你版的体积。 卓越的浏览器兼容性。 React在生产环境中没有用到什么新式偏门的API，因此本来就可以兼容到IE8之下。兼容性越好，我们的后顾之忧越少。 －－－－－－－－－－ 特点： 支持React的无狀态组件，纯组件，高阶组件，受控组件与非受控组件， 命名空间就是React，此外还暴露了另一个别名ReactDOM在window上 体积足够少(1700行相对于react+react-dom的3万行) 性能是官方React的近两倍或更高 测试页面、 结果统计 生命周期函数的参数与官方保持一致 直接与react-redux, react-router-dom, react-router-redux混用 支持后端渲染 支持官方的chrome DevTools 详细用法与示例见 wiki class A extends React.PureComponent { constructor(props) { super(props) this.state = { aaa: { a: 7 } } } click() { this.setState(function(state){ state.aaa.a = 8 }) } render() { return {this.state.aaa.a} } } window.onload = function () { ReactDOM.render(, document.getElementById('example')) } 这个怎么点击也不会变 class Select extends React.Component{ constructor(props){ super(props) this.state = { value: props.value } this.onUpdate = props.onUpdate this.onChange = this.onChange.bind(this) } componentWillReceiveProps(props){ this.state = { //更新自己 value: props.value } } onChange(e){//让父组件更新自己 this.onUpdate(e.target.value) } render(){ return 北京 南京 东京 } } class App extends React.Component{ constructor(props){ super(props) this.state = { value: '南京' } } onUpdate(value){ //让子组件调用这个父组件的方法 this.setState({ value: value }) } onChange(e){ this.onUpdate(e.target.value) } render(){ return } } window.onload = function () { ReactDOM.render(, document.getElementById('example')) } 测试 与Redux使用的例子 var addTodoActions = function (text) { return { type: 'add_todo', text: text }; } var todoReducer = function (state, action) { if (typeof state === 'undefined') { return []; } switch (action.type) { case 'add_todo': return state.slice(0).concat({ text: action.text, completed: false }); break; default: return state; } }; var store = Redux.createStore(todoReducer); class App extends React.Component { constructor(props){ super(props) this.state = { items: store.getState() } this.onChange = this.onChange.bind(this) this.handleKeyUp = this.handleKeyUp.bind(this) this.handleAdd = this.handleAdd.bind(this) } componentDidMount(){ var unsubscribe = store.subscribe(this.onChange); } onChange(){ this.setState({ items: store.getState() }); } handleKeyUp(e){ if(e.which === 13){ this.handleAdd() } } handleAdd(){ var input = this.refs.todo var value = input.value.trim(); if(value) store.dispatch(addTodoActions(value)); input.value = ''; } render(){ return ( 点击添加 {this.state.items.map(function(item){ return {item.text}; })} ); } }; ReactDOM.render( , document.getElementById('example') ); 测试 测试 依赖于 selenium-server-standalone chromedriver, more available drivers nodejs v6.10.0+ karma cli npm install selenium-standalone selenium-standalone install --config=./s.js selenium-standalone start //另开窗口 npm run build 或者 //linux32可以改成mac, window ``` wget https://chromedriver.storage.googleapis.com/2.29/chromedriver_linux32.zip unzip chromedriver_linux32.zip wget http://selenium-release.storage.googleapis.com/3.3/selenium-server-standalone-3.3.1.jar java -jar selenium-server-standalone-3.3.1.jar //另开窗口 npm run build `` "},"install.html":{"url":"install.html","title":"安装","keywords":"","body":"安装 npm i anujs "},"warn.html":{"url":"warn.html","title":"注意事项","keywords":"","body":"注意点 目前没有支持的方法与对象 PropTypes childContextTypes(不需要定义它，就能使用context) Children的方法集合（不完整） mixin机制 createClass cloneElement 低版本浏览器可能需要以下 语言补丁 Array.isArray Object.assign JSON.stringify console-polyfill es6-Map 或者直接使用polyfill.js https://github.com/RubyLouvre/anu/tree/master/dist/polyfill.js "},"jsx.html":{"url":"jsx.html","title":"JSX","keywords":"","body":"JSX React的核心机制之一就是可以在内存中创建虚拟DOM。React利用虚拟DOM来减少对实际DOM的操作从而提升性能。 为了方便使用虚拟DOM，React发明了JSX， 可以简单地理解它是一种在JS中编写与XML类似的语言。通过JSX来声明组件的属性，类型与结果，并且通过｀{}`插值，套嵌JS逻辑与子级的JSX。 要JSX语法，你必须要引入babel的JSX解析器，把JSX转化成JS语法，这个工作会由babel自动完成。同时引入babel后，你就可以使用新的es6语法，babel会帮你把es6语法转化成es5语法，兼容更多的浏览器。 大家可以在这里下载最新版babel http://www.bootcdn.cn/babel-core/ 我们从最简单的一个官网例子helloworld开始： Hello React! ReactDOM.render( Hello, world!, document.getElementById('example') ); script标签里面的内容实际会被编译成 ReactDOM.render( React.createElement('h1',null, 'Hello, world!'), document.getElementById('example') ); 又如 var root =( First Text Content Second Text Content ); 会被编译成 var root = React.createElement('ul', { className: 'my-list' }, React.createElement('li', null, 'First Text Content'), React.createElement('li', null, 'Second Text Content') ); JSX语法介绍 ｀{}`插值是让JSX区别普通HTML的一个重要特性，只有三个地方可以使用它。可以放属性名的地方，属性等于号之后的位置及innerHTML之间。 1.可以放属性名的地方, 这里只能使用JSXSpreadAttribute(延伸属性)， 换言之，括号内必须带三个点号 var props = {}; props.foo = x; props.bar = y; var component = ; 2.属性等于号之后的位置, JSX的属性值必须用引号括起来，当你将引号改成花括号，它里面就可以使用JSX变量了。相当于其他框架的绑定属性或指令。需要说明一下，HTML的固有属性必须使用JS形式，保持驼峰风格，如class要用className代替，for要用htmlFor代替，tabindex要用tabIndex代替，colspan要用colSpan代替。 花括号里面可以使用三元表达式 var person = ; 会编译成 var person = React.createElement( Person, {name: window.isLoggedIn ? window.name : ''} ); 3.innerHTML xxx{111}yyy 这个会编译成, 相邻的字任串或数字会合并成一个字符串，布尔，null, undefined会被忽略掉。 React.createElement('div',null,\"xxx111yyy\") 在innerHTML里面，我们可以使用数组或数组的map方法生成一个新数组的方法，为当前父元素添加一堆子元素。 var ul = ( { this.todoList.todos.map(function (todo) { return ( {todo.text} ); }) } ); JSX中绑定事件 JSX让事件直接绑定在元素上。 Submit 和原生HTML定义事件的唯一区别就是JSX采用驼峰写法来描述事件名称，大括号中仍然是标准的JavaScript表达式，返回一个事件处理函数。 React并不会真正的绑定事件到每一个具体的元素上，而是采用事件代理的模式：在根节点document上为每种事件添加唯一的Listener，然后通过事件的target找到真实的触发元素。这样从触发元素到顶层节点之间的所有节点如果有绑定这个事件，React都会触发对应的事件处理函数。这就是所谓的React模拟事件系统。尽管整个事件系统由React管理，但是其API和使用方法与原生事件一致。 JSX中使用样式 在JSX中使用样式和真实的样式也很类似，通过style属性来定义，但和真实DOM不同的是，`属性值不能是字符串而必须为对象｀。 Hello World. 或者 var style = { color: '#ff0000', fontSize: '14px' }; var node = HelloWorld.; 要明确记住,{}里面是JS代码,这里传进去的是标准的JS对象。在JSX中可以使用所有的的样式，基本上属性名的转换规范就是将其写成驼峰写法，例如“background-color”变为“backgroundColor”, “font-size”变为“fontSize”，这和标准的JavaScript操作DOM样式的API是一致的。 HTML转义 在组件内部添加html代码,并将html代码渲染到页面上。React默认会进行HTML的转义，避免XSS攻击， 如果要不转义，可以使用dangerouslySetInnerHTML属性。dangerouslySetInnerHTML要求对应一个对象，里面有一个叫__html的字符串。React故意搞得这么难写，目的让大家少点用它。 var content='content'; React.render( , document.body ); 自定义组件 组件定义之后，可以利用XML语法去声明，而能够使用的XML Tag就是在当前JavaScript上下文的变量名,该变量名就是组件名称。 一般来说，我们可以通过标签名的第一个字母是大写还是小写来识别组件与普通标签。 class HelloWorld extends React.Component{ render() { return ( Hello, ! It is {this.props.date.toTimeString()} ); } }; setInterval(function() { ReactDOM.render( , document.getElementById('example') ); }, 500); "}}